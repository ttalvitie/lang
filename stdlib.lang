//------------------------------------------------------------------------------------------------//
// STANDARD LIBRARY                                                                               //
//------------------------------------------------------------------------------------------------//

//--- Basic boilerplate ---//

// Set the empty variable name to the identity function to allow parenthesization in expressions.
@ = [x]{ x };

// Store the start of the currently unreserved heap memory in the 'brk' variable.
@brk = __builtin_initialProgramBreak;

//--- Foundation functions implemented in machine code ---//

// _writeSomeStdout(buf, size):
//      Write at least one and up to 'size' bytes from 'buf' to stdout. Returns the number of bytes
//      written or zero if writing fails. 'size' must be nonzero.
//
// Implementation in NASM syntax:
//          pop ebp             ; Pop the return address to ebp.
//          cmp eax, 2
//  fail:   jne fail            ; If the number of arguments is not 2, loop forever.
//          mov eax, 4          ; Use the "write" system call.
//          mov ebx, 1          ; Use standard output.
//          pop ecx             ; Use the 'buf' argument as buffer address.
//          pop edx             ; Use the 'size' argument as the maximum number of bytes to write.
//          int 0x80            ; Perform the system call; return value is saved to eax.
//          cmp eax, 1
//          jl fail2            ; If an error occured (nonpositive return value), jump to fail2.
//          jmp ebp             ; Return to the return address (the number of bytes written is already in eax).
//  fail2:  mov eax, 0          ; Set the return value to 0 to mark the error
//          jmp ebp             ; Return to the return address.
//
@_writeSomeStdout = $5D83F80275FEB804000000BB01000000595ACD8083F8017C02FFE5B800000000FFE5;

// _readSomeStdin(buf, size):
//      Read up to 'size' bytes from stdin to 'buf'. Return the number of bytes read, or (0 - 1) if
//      reading fails. 'size' must be nonzero. If 0 is returned, the end of the file has been
//      reached.
//
// Implementation in NASM syntax:
//          pop ebp             ; Pop the return address to ebp.
//          cmp eax, 2
//  fail:   jne fail            ; If the number of arguments is not 2, loop forever.
//          mov eax, 3          ; Use the "read" system call.
//          mov ebx, 0          ; Use standard input.
//          pop ecx             ; Use the 'buf' argument as buffer address.
//          pop edx             ; Use the 'size' argument as the maximum number of bytes to read.
//          int 0x80            ; Perform the system call; return value is saved to eax.
//          cmp eax, 0
//          jl fail2            ; If an error occured (negative return value), jump to fail2.
//          jmp ebp             ; Return to the return address (the number of bytes read is already in eax).
//  fail2:  mov eax, -1         ; Set the return value to (0 - 1) to mark the error.
//          jmp ebp             ; Return to the return address.
//
@_readSomeStdin = $5D83F80275FEB803000000BB00000000595ACD8083F8007C02FFE5B8FFFFFFFFFFE5;

// _exit(code): Exit with given code. Does not return.
//
// Implementation in NASM syntax:
//          cmp eax, 1
//  fail:   jne fail            ; If the number of arguments is not 1, loop forever.
//          mov eax, 1          ; Use the "exit" system call.
//          mov ebx, [esp+4]    ; Use 'code' as the exit code.
//          int 0x80            ; Perform the system call.
//  loop:   jmp loop            ; Go to infinite loop, just in case.
//
@_exit = $83F80175FEB8010000008B5C2404CD80EBFE;

// _runWhileTrue(func): Call func repeatedly until it returns false (0).
//
// Implementation in NASM syntax:
//          cmp eax, 1
//  fail:   jne fail            ; If the number of arguments is not 1, loop forever.
//  loop:   mov eax, 0          ; Set eax (the number of arguments for the call) to 0.
//          call [esp+4]        ; Call 'func'.
//          cmp eax, 0
//          jne loop            ; If the return value is nonzero, retry calling the function.
//          pop ebp             ; Pop the return address to ebp.
//          add esp, 4          ; Discard the 'func' argument from the stack.
//          jmp ebp             ; Return to the return address (the return value eax is already 0).
//
@_runWhileTrue = $83F80175FEB800000000FF54240483F80075F25D83C404FFE5;

// _get8(addr): Read 8-bit value from given address and return it.
//
// Implementation in NASM syntax:
//          pop ebp             ; Pop the return address to ebp.
//          cmp eax, 1
//  fail:   jne fail            ; If the number of arguments is not 1, loop forever.
//          pop ebx             ; Pop the address to read to ebx.
//          mov al, [ebx]       ; Read the byte to the bottom byte of eax (the rest of the bytes are zero already).
//          jmp ebp             ; Return to the return address.
//
@_get8 = $5D83F80175FE5B8A03FFE5;

// _put8(addr, val): Write the bottom byte of 'val' to 'addr'.
//
// Implementation in NASM syntax:
//          pop ebp             ; Pop the return address to ebp.
//          cmp eax, 2
//  fail:   jne fail            ; If the number of arguments is not 2, loop forever.
//          pop ebx             ; Pop 'addr' to ebx.
//          pop ecx             ; Pop 'val' to ecx.
//          mov [ebx], cl       ; Write the bottom byte of ecx to the address ebx.
//          mov eax, 0          ; Set the return value eax to 0.
//          jmp ebp             ; Return to the return address.
//
@_put8 = $5D83F80275FE5B59880BB800000000FFE5;

// _bitAnd(a, b): Compute the bitwise AND of 'a' and 'b'.
//
// Implementation in NASM syntax:
//          pop ebp             ; Pop the return address to ebp.
//          cmp eax, 2
//  fail:   jne fail            ; If the number of arguments is not 2, loop forever.
//          pop eax             ; Pop 'a' to eax.
//          pop ebx             ; Pop 'b' to ebx.
//          and eax, ebx        ; Compute the result to eax.
//          jmp ebp             ; Return to the return address.
//
@_bitAnd = $5D83F80275FE585B21D8FFE5;

// _bitXor(a, b): Compute the bitwise XOR of 'a' and 'b'.
//
// Implementation in NASM syntax:
//          pop ebp             ; Pop the return address to ebp.
//          cmp eax, 2
//  fail:   jne fail            ; If the number of arguments is not 2, loop forever.
//          pop eax             ; Pop 'a' to eax.
//          pop ebx             ; Pop 'b' to ebx.
//          xor eax, ebx        ; Compute the result to eax.
//          jmp ebp             ; Return to the return address.
//
@_bitXor = $5D83F80275FE585B31D8FFE5;

// _bitNot(val): Compute the bitwise NOT of given value.
//
// Implementation in NASM syntax:
//          pop ebp             ; Pop the return address to ebp.
//          cmp eax, 1
//  fail:   jne fail            ; If the number of arguments is not 1, loop forever.
//          pop eax             ; Pop 'a' to eax.
//          not eax             ; Compute the result to eax.
//          jmp ebp             ; Return to the return address.
//
@_bitNot = $5D83F80175FE58F7D0FFE5;

// _shiftLeftMasked(a, b): Compute 'a' shifted to the left by 'b % 32'.
//
// Implementation in NASM syntax:
//          pop ebp             ; Pop the return address to ebp.
//          cmp eax, 2
//  fail:   jne fail            ; If the number of arguments is not 2, loop forever.
//          pop eax             ; Pop 'a' to eax.
//          pop ecx             ; Pop 'b' to ecx.
//          shl eax, cl         ; Compute the result to eax.
//          jmp ebp             ; Return to the return address.
//
@_shiftLeftMasked = $5D83F80275FE5859D3E0FFE5;

// _shiftRightMasked(a, b): Compute 'a' shifted to the right by 'b % 32'.
//
// Implementation in NASM syntax:
//          pop ebp             ; Pop the return address to ebp.
//          cmp eax, 2
//  fail:   jne fail            ; If the number of arguments is not 2, loop forever.
//          pop eax             ; Pop 'a' to eax.
//          pop ecx             ; Pop 'b' to ecx.
//          shr eax, cl         ; Compute the result to eax.
//          jmp ebp             ; Return to the return address.
//
@_shiftRightMasked = $5D83F80275FE5859D3E8FFE5;

//--- Memory access ---//

@get8 = [addr]{
    _get8(addr)
};
@put8 = [addr, val]{
    _put8(addr, val)
};

//--- Variadic function support ---//

// Creates and returns a variadic function that calls func(argCount, args) where argCount is the
// number of arguments it receives and args is the argument array.
@toVariadic = [func]{
    // Helper function that forwards the call. Assumes that 'func' is in ebx.
    //
    // Implementation in NASM syntax:
    //          push eax            ; Retain the number of arguments in stack.
    //          mov ecx, esp        ; Write the stack pointer to ecx.
    //          add ecx, 8          ; Increase ecx by 8 so that it points to the beginning of the argument list.
    //          push ecx            ; Push the pointer to the argument list as the 'args' argument for 'func'.
    //          push eax            ; Push the number of arguments as the 'argCount' argument for 'func'.
    //          mov eax, 2          ; Set the number of arguments for 'func' to 2.
    //          call ebx            ; Call 'func'.
    //          pop ebx             ; Pop the number of arguments from stack to ebx.
    //          shl ebx, 2          ; Multiply the number of arguments by 4 to get the argument list size in bytes.
    //          pop ebp             ; Pop the return address to ebp.
    //          add esp, ebx        ; Discard the argument list from the stack.
    //          jmp ebp             ; Return to the return address (eax still contains the 'func' return value).
    //
    @helper = $5089E183C1085150B802000000FFD35BC1E3025D01DCFFE5;

    @ret = brk;

    // mov ebx, 'func': Write 'func' to ebx.
    put8(brk, #BB);
    brk = brk + 1;
    *brk = func;
    brk = brk + 4;

    // mov ecx, 'helper': Write 'helper' to ecx.
    put8(brk, #B9);
    brk = brk + 1;
    *brk = helper;
    brk = brk + 4;

    // jmp ecx: Jump to 'helper'.
    put8(brk, #FF);
    brk = brk + 1;
    put8(brk, #E1);
    brk = brk + 1;

    ret
};

//--- Minimal error handling ---//

@exit = [code]{
    _exit(code)
};

// fail([fmt, ...])
@fail = toVariadic([argCount, args]{
    exit(1)
});

//--- Control flow ---//

@runWhileTrue = [func]{
    _runWhileTrue(func)
};

@if = [cond, func]{
    @helper = { cond };
    runWhileTrue({
        @continue = helper();
        helper = {
            func();
            0
        };
        continue
    })
};

@ifElse = [cond, trueFunc, falseFunc]{
    @func = falseFunc;
    if(cond, {
        func = trueFunc
    });
    func()
};

@while = [condFunc, func]{
    runWhileTrue({
        ifElse(condFunc(), { func(); 1 }, { 0 })
    })
};

@forRangeWhileTrue = [a, b, func]{
    @i = a;
    @lastRet = 1;
    runWhileTrue({
        ifElse(i < b, {
            lastRet = func(i);
            i = i + 1;
            lastRet
        }, {
            0
        })
    });
    lastRet
};

@forRevRangeWhileTrue = [a, b, func]{
    @i = b;
    @lastRet = 1;
    runWhileTrue({
        ifElse(i > a, {
            i = i - 1;
            lastRet = func(i);
            lastRet
        }, {
            0
        })
    });
    lastRet
};

@forRange = [a, b, func]{
    forRangeWhileTrue(a, b, [i]{
        func(i);
        1
    })
};

@forRevRange = [a, b, func]{
    forRevRangeWhileTrue(a, b, [i]{
        func(i);
        1
    })
};

// ifChain(cond1, func1, cond2, func2, ..., condN, funcN, defaultFunc) calls funcI for the first
// condI() that is nonzero or defaultFunc otherwise.
@ifChain = toVariadic([argCount, args]{
    if(argCount % 2 == 0, {
        fail("Even number of arguments given to ifChain")
    });
    @ret = 0;
    @callDefault = forRangeWhileTrue(0, argCount / 2, [i]{
        ifElse((*(args + 8 * i))(), {
            ret = (*(args + 8 * i + 4))();
            0
        }, {
            1
        })
    });
    if(callDefault, {
        ret = (*(args + 4 * (argCount - 1)))()
    });
    ret
});

//--- Memory block operations ---///

@copyMem = [src, dest, size]{
    while({ size >= 4 }, {
        *dest = *src;
        src = src + 4;
        dest = dest + 4;
        size = size - 4
    });
    while({ size }, {
        put8(dest, get8(src));
        src = src + 1;
        dest = dest + 1;
        size = size - 1
    })
};

@memEqual = [a, b, size]{
    @ret = 1;
    while({ ret && size >= 4 }, {
        ifElse(*a == *b, {
            a = a + 4;
            b = b + 4;
            size = size - 4
        }, {
            ret = 0
        })
    });
    while({ ret && size }, {
        ifElse(get8(a) == get8(b), {
            a = a + 1;
            b = b + 1;
            size = size - 1
        }, {
            ret = 0
        })
    });
    ret
};

@swapMem = [a, b, size]{
    copyMem(a, brk, size);
    copyMem(b, a, size);
    copyMem(brk, b, size)
};

//--- Bitwise operations ---//

@bitAnd = [a, b]{ _bitAnd(a, b) };
@bitOr = [a, b]{ _bitNot(_bitAnd(_bitNot(a), _bitNot(b))) };
@bitNot = [val]{ _bitNot(val) };

@shiftLeft = [a, b]{
    ifElse(b < 32, { _shiftLeftMasked(a, b) }, 0)
};
@shiftRight = [a, b]{
    ifElse(b < 32, { _shiftRightMasked(a, b) }, 0)
};

//--- Strings ---//

@endlStr = "
";

@strLen = [str]{
    @len = 0;
    while({ get8(str + len) }, { len = len + 1 });
    len
};

@strEqual = [a, b]{
    @eq = 1;
    runWhileTrue({
        @x = get8(a);
        @y = get8(b);
        a = a + 1;
        b = b + 1;
        if(x != y, {
            eq = 0
        });
        eq && x
    });
    eq
};

@charNum = [str]{
    if(strLen(str) != 1, {
        fail("charNum: The length of given string is not 1")
    });
    get8(str)
};

//--- Input/output ---//

@writeStdout = [buf, size]{
    while({ size }, {
        @count = _writeSomeStdout(buf, size);
        if(count == 0, {
            fail("Writing to stdout failed")
        });
        buf = buf + count;
        size = size - count
    });
    size
};

@readStdin = [buf, size]{
    @ret = 0;
    while({ size }, {
        @count = _readSomeStdin(buf, size);
        if(count == 0 - 1, {
            fail("Reading from stdin failed")
        });
        ifElse(count, {
            buf = buf + count;
            size = size - count;
            ret = ret + count
        }, {
            // End of file encountered, stop reading.
            size = 0
        })
    });

    // Return the number of bytes read (may be short if the end of the file is encountered).
    ret
};

@printDec = [val]{
    @digit = val % 10;
    @rest = val / 10;
    if(rest, { printDec(rest) });
    digit = digit + 48;
    writeStdout(&digit, 1)
};

@vPrint = [fmt, argCount, args]{
    @i = 0;

    @argIdx = 0;
    @takeArg = {
        if(argIdx >= argCount, {
            fail("Not enough arguments given to print")
        });
        @arg = *(args + 4 * argIdx);
        argIdx = argIdx + 1;
        arg
    };

    @writeStart = 0;
    runWhileTrue({
        @ch = get8(fmt + i);
        ifChain(
            { ch == 0 }, {
                0
            },
            { ch == charNum("%") }, {
                writeStdout(fmt + writeStart, i - writeStart);
                ch = get8(fmt + i + 1);
                if(ch == 0, {
                    fail("Unexpected end of print format string")
                });
                ifChain(
                    { ch == charNum("s") }, {
                        @arg = takeArg();
                        writeStdout(arg, strLen(arg))
                    },
                    { ch == charNum("u") }, {
                        printDec(takeArg())
                    },
                    { ch == charNum("%") }, {
                        writeStdout("%", 1)
                    },
                    {
                        fail("Unknown print format placeholder")
                    }
                );
                i = i + 2;
                writeStart = i;
                1
            },
            {
                i = i + 1;
                1
            }
        )
    });
    writeStdout(fmt + writeStart, i - writeStart);
    if(argIdx != argCount, {
        fail("Extra arguments given to print")
    })
};
@vPrintL = [fmt, argCount, args]{
    vPrint(fmt, argCount, args);
    writeStdout(endlStr, 1)
};

@print = toVariadic([argCount, args]{
    if(argCount, {
        vPrint(*args, argCount - 1, args + 4)
    })
});
@printL = toVariadic([argCount, args]{
    ifElse(argCount, {
        vPrintL(*args, argCount - 1, args + 4)
    }, {
        vPrintL("", 0, 0)
    })
});

@inputLine = {
    @ret = brk;
    runWhileTrue({
        @ch = 0;
        ifElse(readStdin(&ch, 1), {
            ifElse(ch == #A, {
                // Line break encountered.
                0
            }, {
                // Append character to string and continue.
                put8(brk, ch);
                brk = brk + 1;
                1
            })
        }, {
            // End of file encountered.
            0
        })
    });

    // Append the null terminator.
    put8(brk, 0);
    brk = brk + 1;

    ret
};

//--- Error handling ---//

fail = toVariadic([argCount, args]{
    ifElse(argCount, {
        print("FAIL: ");
        vPrintL(*args, argCount - 1, args + 4)
    }, {
        printL("FAIL")
    });

    exit(1)
});

// assert(cond, [fmt, ...])
@assert = toVariadic([argCount, args]{
    if(argCount == 0, {
        fail("assert called with no arguments")
    });
    if(!*args, {
        ifElse(argCount > 1, {
            print("FAIL: Assertion failed: ");
            vPrintL(*(args + 4), argCount - 2, args + 8)
        }, {
            printL("FAIL: Assertion failed")
        });
        exit(1)
    })
});

// Replace the wrong number of arguments handler by one that prints the information to stdout.
__builtin_wrongNumberOfArgumentsHandler = [line, column, correctArgCount, givenArgCount]{
    printL(
        "FAIL: Wrong number of arguments passed to the function defined on line %u, column %u (expected %u arguments, got %u).",
        line, column, correctArgCount, givenArgCount
    );

    exit(1)
};

//--- String conversions ---//

@parseDec = [str]{
    @val = 0;
    @empty = 1;
    runWhileTrue({
        @ch = get8(str);
        ifElse(ch, {
            empty = 0;
            if(!(#30 <= ch <= #39), {
                fail("parseDec: Invalid decimal digit.")
            });
            val = 10 * val + (ch - #30);
            str = str + 1;
            1
        }, {
            // End of string.
            0
        })
    });
    if(empty, {
        fail("parseDec: The string is empty.")
    });
    val
};

//--- Algorithms ---//

@makeHeap = [data, size, itemSize, cmp]{
    forRevRange(0, size, [i]{
        runWhileTrue({
            @a = 2 * i + 1;
            ifElse(a < size, {
                @j = a;
                @b = 2 * i + 2;
                if(b < size && cmp(data + itemSize * a, data + itemSize * b), {
                    j = b
                });
                ifElse(cmp(data + itemSize * i, data + itemSize * j), {
                    swapMem(data + itemSize * i, data + itemSize * j, itemSize);
                    i = j;
                    1
                }, {
                    0
                })
            }, {
                0
            })
        })
    })
};
@popHeap = [data, size, itemSize, cmp]{
    size = size - 1;
    swapMem(data + itemSize * 0, data + itemSize * size, itemSize);

    @i = 0;
    runWhileTrue({
        @a = 2 * i + 1;
        ifElse(a < size, {
            @b = 2 * i + 2;
            @j = a;
            if(b < size && cmp(data + itemSize * a, data + itemSize * b), {
                j = b
            });
            ifElse(cmp(data + itemSize * i, data + itemSize * j), {
                swapMem(data + itemSize * i, data + itemSize * j, itemSize);
                i = j;
                1
            }, {
                0
            })
        }, {
            0
        })
    });
    1
};

@sort = [data, size, itemSize, cmp]{
    makeHeap(data, size, itemSize, cmp);
    forRevRange(1, size + 1, [left]{
        popHeap(data, left, itemSize, cmp)
    })
};

//--- Vector: a resizable array ---//

// Vector internals:
@Vector_data = [vector]{ vector + 0 };
@Vector_itemSize = [vector]{ vector + 4 };
@Vector_size = [vector]{ vector + 8 };
@Vector_capacity = [vector]{ vector + 12 };
@Vector_sizeof = 16;

// Vector public interface:
@Vector.init = [itemSize]{
    @vector = brk;
    brk = brk + Vector_sizeof;
    *Vector_data(vector) = 0;
    *Vector_itemSize(vector) = itemSize;
    *Vector_size(vector) = 0;
    *Vector_capacity(vector) = 0;
    vector
};

@Vector.size = [vector]{
    *Vector_size(vector)
};

@Vector.data = [vector]{
    *Vector_data(vector)
};

@Vector.item = [vector, i]{
    *Vector_data(vector) + *Vector_itemSize(vector) * i
};

@Vector.push = [vector]{
    @itemSize = *Vector_itemSize(vector);
    @oldSize = *Vector_size(vector);

    *Vector_size(vector) = oldSize + 1;

    if(*Vector_size(vector) > *Vector_capacity(vector), {
        *Vector_capacity(vector) = 2 * *Vector_size(vector);
        @oldData = *Vector_data(vector);
        @newData = brk;
        brk = brk + itemSize * *Vector_capacity(vector);
        *Vector_data(vector) = newData;
        copyMem(oldData, newData, itemSize * oldSize)
    });
    Vector.item(vector, oldSize)
};

@Vector.sort = [vector, cmp]{
    sort(Vector.data(vector), Vector.size(vector), *Vector_itemSize(vector), cmp)
};

//------------------------------------------------------------------------------------------------//
// PROGRAM                                                                                        //
//------------------------------------------------------------------------------------------------//
