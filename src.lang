% =add(...): Return the sum of all arguments.
%
% Assembly source:
%           pop ebp         ; Pop the return address to ebp.
%           pop eax         ; Pop the number of arguments to eax.
%           cmp eax, 0
%   fail:   je fail         ; If there are no arguments, loop forever. (TODO: better error handling)
%           pop ebx         ; Pop the return value address to ebx.
%           mov ecx, 0      ; Initialize result storage in ecx to zero.
%   loop:   dec eax         ; Decrement eax, maintaining it as the number of unprocessed arguments.
%           cmp eax, 0
%           je done         ; If there are no unprocessed arguments remaining, end loop.
%           pop edx         ; Pop the next argument to edx.
%           add ecx, edx    ; Add the argument to the result in ecx.
%           jmp loop        ; Continue loop.
%   done:   mov [ebx], ecx  ; Save the result to the return value address.
%           jmp ebp         ; Return to the return address.
%
add : ($5D5883F80074FE5BB9000000004883F80074055A01D1EBF5890BFFE5)

% =mul(...): Return the product of all arguments.
%
% Assembly source:
%           pop ebp         ; Pop the return address to ebp.
%           pop ecx         ; Pop the number of arguments to ecx.
%           cmp ecx, 0
%   fail:   je fail         ; If there are no arguments, loop forever. (TODO: better error handling)
%           pop ebx         ; Pop the return value address to ebx.
%           mov eax, 1      ; Initialize result storage in eax to zero.
%   loop:   dec ecx         ; Decrement ecx, maintaining it as the number of unprocessed arguments.
%           cmp ecx, 0
%           je done         ; If there are no unprocessed arguments remaining, end loop.
%           pop edx         ; Pop the next argument to edx.
%           mul edx         ; Multiple the result in eax by the argument (edx gets overwritten).
%           jmp loop        ; Continue loop.
%   done:   mov [ebx], eax  ; Save the result to the return value address.
%           jmp ebp         ; Return to the return address.
%
mul : ($5D5983F90074FE5BB8010000004983F90074055AF7E2EBF58903FFE5)

% =sub(a, b): Return the difference of 'a' and 'b'.
%
% Assembly source:
%           pop ebp         ; Pop the return address to ebp.
%           pop eax         ; Pop the number of arguments to eax.
%           cmp eax, 3
%   fail:   jne fail        ; If the number of arguments is not 3, loop forever. (TODO: better error handling)
%           pop ecx         ; Pop the return value address to ecx.
%           pop eax         ; Pop 'a' to eax.
%           pop ebx         ; Pop 'b' to ebx.
%           sub eax, ebx    ; Compute the difference to eax.
%   done:   mov [ecx], eax  ; Save the result to the return value address.
%           jmp ebp         ; Return to the return address.
%
sub : ($5D5883F80375FE59585B29D88901FFE5)

% =lt(a, b): Returns 1 if 'a' is less than 'b', and 0 otherwise.
%
% Assembly source:
%           pop ebp         ; Pop the return address to ebp.
%           pop eax         ; Pop the number of arguments to eax.
%           cmp eax, 3
%   fail:   jne fail        ; If the number of arguments is not 3, loop forever. (TODO: better error handling)
%           pop ecx         ; Pop the return value address to ecx.
%           pop eax         ; Pop 'a' to eax.
%           pop ebx         ; Pop 'b' to ebx.
%           mov edx, 0      ; Set result value to 0.
%           cmp eax, ebx
%           setb dl         ; If eax is less than ebx, set result to 1.
%           mov [ecx], edx  ; Save the result to the return value address.
%           jmp ebp         ; Return to the return address.
%
lt : ($5D5883F80375FE59585BBA0000000039D80F92C28911FFE5)

% =readSomeStdin(buf, size):
%   Read up to 'size' bytes from stdin to 'buf'. Return the number of bytes read. 'size' must be
%   nonzero. If 0 is returned, the end of the file has been reached.
%
% Assembly source:
%           pop ebp         ; Pop the return address to ebp.
%           pop eax         ; Pop the number of arguments to eax.
%           cmp eax, 3
%   fail:   jne fail        ; If the number of arguments is not 3, loop forever. (TODO: better error handling)
%           pop edi         ; Pop the return value address to edi.
%           mov eax, 3      ; Use the "read" system call.
%           mov ebx, 0      ; Use standard input.
%           pop ecx         ; Use the 'buf' argument as output address.
%           pop edx         ; Use the 'size' argument as the maximum number of bytes to read.
%           int 0x80        ; Perform the system call.
%           cmp eax, 0
%   fail2:  jl fail2        ; If an error occured (negative return value), loop forever. (TODO: better error handling)
%           mov [edi], eax  ; Save the number of read bytes to the return value address.
%           jmp ebp         ; Return to the return address.
%
readSomeStdin : ($5D5883F80375FE5FB803000000BB00000000595ACD8083F8007CFE8907FFE5)

% =writeSomeStdout(buf, size):
%   Write up to 'size' bytes from 'buf' to stdout. Return the number of bytes written. 'size' must
%   be nonzero. Writes at least one byte.
%
% Assembly source:
%           pop ebp         ; Pop the return address to ebp.
%           pop eax         ; Pop the number of arguments to eax.
%           cmp eax, 3
%   fail:   jne fail        ; If the number of arguments is not 3, loop forever. (TODO: better error handling)
%           pop edi         ; Pop the return value address to edi.
%           mov eax, 4      ; Use the "write" system call.
%           mov ebx, 1      ; Use standard output.
%           pop ecx         ; Use the 'buf' argument as output address.
%           pop edx         ; Use the 'size' argument as the maximum number of bytes to write.
%           int 0x80        ; Perform the system call.
%           cmp eax, 1
%   fail2:  jl fail2        ; If an error occured (nonpositive return value), loop forever. (TODO: better error handling)
%           mov [edi], eax  ; Save the number of bytes written to the return value address.
%           jmp ebp         ; Return to the return address.
%
writeSomeStdout : ($5D5883F80375FE5FB804000000BB01000000595ACD8083F8017CFE8907FFE5)

% whileReturnsTrue(=func):
%   Call func repeatedly until it returns true (nonzero).
%
% Assembly source:
%           cmp dword [esp+4], 1
%   fail:   jne fail                ; If the number of arguments is not 1, loop forever. (TODO: better error handling)
%   loop:   mov eax, esp            ; Copy stack pointer to eax.
%           add eax, 4              ; Offset pointer in eax such that it points to the first argument (which we no longer need).
%           push eax                ; Push the pointer to the first argument to the stack as the return value argument for 'func'.
%           push 1                  ; Push 1 to the stack as the number of arguments for the 'func' call.
%           call [esp+16]           ; Call 'func'.
%           cmp dword [esp+4], 0    ; Compare the return value to zero.
%           jne loop                ; If the return value is nonzero, continue loop.
%           pop eax                 ; Copy the return address to eax.
%           add esp, 8              ; Discard the argument list.
%           jmp eax                 ; Return to the return address.
%
whileReturnsTrue : ($837C24040175FE89E083C004506A01FF542410837C24040075ED5883C408FFE0)

% Define put as an alias for the empty-name 32-bit memory write function.
put : (0)
(&put, )

% Comparison operators.
eq : ([pRet, a, b]{ put(pRet, lt(sub(a, b), 1)) })
ne : ([pRet, a, b]{ put(pRet, sub(1, eq(a, b))) })
gt : ([pRet, a, b]{ put(pRet, lt(b, a)) })
leq : ([pRet, a, b]{ put(pRet, sub(1, gt(a, b))) })
geq : ([pRet, a, b]{ put(pRet, sub(1, lt(a, b))) })

% Logical operators.
not : ([pRet, x]{ put(pRet, eq(x, 0)) })
and : ([pRet, a, b]{ put(pRet, not(add(not(a), not(b)))) })
or : ([pRet, a, b]{ put(pRet, not(and(not(a), not(b)))) })

% Control flow functions.
if : ([cond, func]{
    helper : ([pRet]{
        put(pRet, cond)
    })
    whileReturnsTrue([pContinue]{
        put(pContinue, helper())
        helper = ([pRet]{
            func()
            put(pRet, 0)
        })
    })
})


if(eq(5, 5), {
    y : writeSomeStdout($616263640A, 5)
})
