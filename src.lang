//------------------------------------------------------------------------------------------------//
// STANDARD LIBRARY                                                                               //
//------------------------------------------------------------------------------------------------//

//--- Basic boilerplate ---//

// Set the empty variable name to the identity function to allow parenthesization in expressions.
@ = [x]{ x };

// Store the start of the currently unreserved heap memory in the 'brk' variable.
@brk = __builtin_initialProgramBreak;

//--- Foundation functions implemented in machine code ---//

// _writeSomeStdout(buf, size):
//      Write at least one and up to 'size' bytes from 'buf' to stdout. Returns the number of bytes
//      written or zero if writing fails. 'size' must be nonzero.
//
// Implementation in NASM syntax:
//          pop ebp             ; Pop the return address to ebp.
//          cmp eax, 2
//  fail:   jne fail            ; If the number of arguments is not 2, loop forever.
//          mov eax, 4          ; Use the "write" system call.
//          mov ebx, 1          ; Use standard output.
//          pop ecx             ; Use the 'buf' argument as buffer address.
//          pop edx             ; Use the 'size' argument as the maximum number of bytes to write.
//          int 0x80            ; Perform the system call; return value is saved to eax.
//          cmp eax, 1
//          jl fail2            ; If an error occured (nonpositive return value), jump to fail2.
//          jmp ebp             ; Return to the return address (the number of bytes written is already in eax).
//  fail2:  mov eax, 0          ; Set the return value to 0 to mark the error
//          jmp ebp             ; Return to the return address.
//
@_writeSomeStdout = $5D83F80275FEB804000000BB01000000595ACD8083F8017C02FFE5B800000000FFE5;

// _readSomeStdin(buf, size):
//      Read up to 'size' bytes from stdin to 'buf'. Return the number of bytes read, or (0 - 1) if
//      reading fails. 'size' must be nonzero. If 0 is returned, the end of the file has been
//      reached.
//
// Implementation in NASM syntax:
//          pop ebp             ; Pop the return address to ebp.
//          cmp eax, 2
//  fail:   jne fail            ; If the number of arguments is not 2, loop forever.
//          mov eax, 3          ; Use the "read" system call.
//          mov ebx, 0          ; Use standard input.
//          pop ecx             ; Use the 'buf' argument as buffer address.
//          pop edx             ; Use the 'size' argument as the maximum number of bytes to read.
//          int 0x80            ; Perform the system call; return value is saved to eax.
//          cmp eax, 0
//          jl fail2            ; If an error occured (negative return value), jump to fail2.
//          jmp ebp             ; Return to the return address (the number of bytes read is already in eax).
//  fail2:  mov eax, -1         ; Set the return value to (0 - 1) to mark the error.
//          jmp ebp             ; Return to the return address.
//
@_readSomeStdin = $5D83F80275FEB803000000BB00000000595ACD8083F8007C02FFE5B8FFFFFFFFFFE5;

// _runWhileTrue(func): Call func repeatedly until it returns false (0).
//
// Implementation in NASM syntax:
//          cmp eax, 1
//  fail:   jne fail            ; If the number of arguments is not 1, loop forever.
//  loop:   mov eax, 0          ; Set eax (the number of arguments for the call) to 0.
//          call [esp+4]        ; Call 'func'.
//          cmp eax, 0
//          jne loop            ; If the return value is nonzero, retry calling the function.
//          pop ebp             ; Pop the return address to ebp.
//          add esp, 4          ; Discard the 'func' argument from the stack.
//          jmp ebp             ; Return to the return address (the return value eax is already 0).
//
@_runWhileTrue = $83F80175FEB800000000FF54240483F80075F25D83C404FFE5;

// _get8(addr): Read 8-bit value from given address and return it.
//
// Implementation in NASM syntax:
//          pop ebp             ; Pop the return address to ebp.
//          cmp eax, 1
//  fail:   jne fail            ; If the number of arguments is not 1, loop forever.
//          pop ebx             ; Pop the address to read to ebx.
//          mov al, [ebx]       ; Read the byte to the bottom byte of eax (the rest of the bytes are zero already).
//          jmp ebp             ; Return to the return address.
//
@_get8 = $5D83F80175FE5B8A03FFE5;

// _put8(addr, val): Write the bottom byte of 'val' to 'addr'.
//
// Implementation in NASM syntax:
//          pop ebp             ; Pop the return address to ebp.
//          cmp eax, 2
//  fail:   jne fail            ; If the number of arguments is not 2, loop forever.
//          pop ebx             ; Pop 'addr' to ebx.
//          pop ecx             ; Pop 'val' to ecx.
//          mov [ebx], cl       ; Write the bottom byte of ecx to the address ebx.
//          mov eax, 0          ; Set the return value eax to 0.
//          jmp ebp             ; Return to the return address.
//
@_put8 = $5D83F80275FE5B59880BB800000000FFE5;

//--- Memory access ---///

@get8 = [addr]{
    _get8(addr)
};
@put8 = [addr, val]{
    _put8(addr, val)
};

//--- Control flow ---//

@runWhileTrue = [func]{
    _runWhileTrue(func)
};

@if = [cond, func]{
    @helper = { cond };
    runWhileTrue({
        @continue = helper();
        helper = {
            func();
            0
        };
        continue
    })
};

@ifElse = [cond, trueFunc, falseFunc]{
    @func = falseFunc;
    if(cond, {
        func = trueFunc
    });
    func()
};

@while = [condFunc, func]{
    runWhileTrue({
        ifElse(condFunc(), { func(); 1 }, { 0 })
    })
};

@forRangeWhileTrue = [a, b, func]{
    @i = a;
    runWhileTrue({
        ifElse(i < b, {
            @ret = func(i);
            i = i + 1;
            ret
        }, {
            0
        })
    })
};

@forRange = [a, b, func]{
    forRangeWhileTrue(a, b, [i]{
        func(i);
        1
    })
};

//--- Error handling (minimal implementations; replaced later) ---//

// Fail the program with given error message string. Does not return.
@fail = [msg]{
    // Go to infinite loop.
    runWhileTrue({ 1 })
};

//--- Strings ---//

@endlStr = "
";

//--- Input/output ---//

@writeStdout = [buf, size]{
    while({ size }, {
        @count = _writeSomeStdout(buf, size);
        if(count == 0, {
            fail("Writing to stdout failed")
        });
        buf = buf + count;
        size = size - count
    });
    size
};

@readStdin = [buf, size]{
    @ret = 0;
    while({ size }, {
        @count = _readSomeStdin(buf, size);
        if(count == 0 - 1, {
            fail("Reading from stdin failed")
        });
        ifElse(count, {
            buf = buf + count;
            size = size - count;
            ret = ret + count
        }, {
            // End of file encountered, stop reading.
            size = 0
        })
    });

    // Return the number of bytes read (may be short if the end of the file is encountered).
    ret
};

@printDec = [val]{
    @digit = val % 10;
    @rest = val / 10;
    if(rest, { printDec(rest) });
    digit = digit + 48;
    writeStdout(&digit, 1)
};

@printStr = [str]{
    @len = 0;
    while({ get8(str + len) }, { len = len + 1 });
    writeStdout(str, len)
};

@printDecL = [val]{
    printDec(val);
    printStr(endlStr)
};

@printStrL = [str]{
    printStr(str);
    printStr(endlStr)
};

@inputLine = {
    @ret = brk;
    runWhileTrue({
        @ch = 0;
        ifElse(readStdin(&ch, 1), {
            ifElse(ch == #A, {
                // Line break encountered.
                0
            }, {
                // Append character to string and continue.
                put8(brk, ch);
                brk = brk + 1;
                1
            })
        }, {
            // End of file encountered.
            0
        })
    });

    // Append the null terminator.
    put8(brk, 0);
    brk = brk + 1;

    ret
};

//--- Error handling (replacing earlier implementations) ---//

fail = [msg]{
    printStr("FAIL: ");
    printStr(msg);
    printStr(endlStr);

    // Go to infinite loop.
    runWhileTrue({ 1 })
};

// Replace the wrong number of arguments handler by one that prints the information to stdout.
__builtin_wrongNumberOfArgumentsHandler = [line, column, correctArgCount, givenArgCount]{
    printStr("FAIL: Wrong number of arguments passed to the function defined on line ");
    printDec(line);
    printStr(", column ");
    printDec(column);
    printStr(" (expected ");
    printDec(correctArgCount);
    printStr(" arguments, got ");
    printDec(givenArgCount);
    printStrL(").");

    // Go to infinite loop.
    runWhileTrue({ 1 })
};

//--- String conversions ---//

@parseDec = [str]{
    @val = 0;
    @empty = 1;
    runWhileTrue({
        @ch = get8(str);
        ifElse(ch, {
            empty = 0;
            if(!(#30 <= ch <= #39), {
                fail("parseDec: Invalid decimal digit.")
            });
            val = 10 * val + (ch - #30);
            str = str + 1;
            1
        }, {
            // End of string.
            0
        })
    });
    if(empty, {
        fail("parseDec: The string is empty.")
    });
    val
};

//------------------------------------------------------------------------------------------------//
// PROGRAM                                                                                        //
//------------------------------------------------------------------------------------------------//

// Allocate array of total calories of top elves (initially zero).
@topCount = 3;
@topCaloriesBuf = brk;
brk = brk + 4 * topCount;
@topCalories = [i]{
    topCaloriesBuf + 4 * i
};
forRange(0, topCount, [i]{
    *topCalories(i) = 0
});

runWhileTrue({
    // Count the calories for this elf.
    @totalCalories = 0;
    @itemsFound = 0;
    runWhileTrue({
        @line = inputLine();
        ifElse(get8(line), {
            // Nonempty line -> new item.
            totalCalories = totalCalories + parseDec(line);
            itemsFound = 1;
            1
        }, {
            // Empty line -> end of item list for this elf.
            0
        })
    });

    ifElse(itemsFound, {
        // Insert totalCalories to bestCalories.
        forRangeWhileTrue(0, topCount, [i]{
            ifElse(totalCalories > *topCalories(i), {
                if(i > 0, {
                    *topCalories(i - 1) = *topCalories(i)
                });
                *topCalories(i) = totalCalories;
                1
            }, {
                0
            })
        });
        1
    }, {
        // No items found -> all elves processed.
        0
    })
});

printDecL(*topCalories(topCount - 1));

@topCaloriesSum = 0;
forRange(0, topCount, [i]{
    topCaloriesSum = topCaloriesSum + *topCalories(i)
});

printDecL(topCaloriesSum);

0
