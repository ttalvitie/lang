//------------------------------------------------------------------------------------------------//
// STANDARD LIBRARY                                                                               //
//------------------------------------------------------------------------------------------------//

//--- Basic boilerplate ---//

// Set the empty variable name to the identity function to allow parenthesization in expressions.
@ = [x]{ x };

// Store the start of the currently unreserved heap memory in the 'brk' variable.
@brk = __builtin_initialProgramBreak;

//--- Foundation functions implemented in machine code ---//

// _writeSomeStdout(buf, size):
//      Write at least one and up to 'size' bytes from 'buf' to stdout. Returns the number of bytes
//      written or zero if writing fails. 'size' must be nonzero.
//
// Implementation in NASM syntax:
//          pop ebp             ; Pop the return address to ebp.
//          cmp eax, 2
//  fail:   jne fail            ; If the number of arguments is not 2, loop forever.
//          mov eax, 4          ; Use the "write" system call.
//          mov ebx, 1          ; Use standard output.
//          pop ecx             ; Use the 'buf' argument as buffer address.
//          pop edx             ; Use the 'size' argument as the maximum number of bytes to write.
//          int 0x80            ; Perform the system call; return value is saved to eax.
//          cmp eax, 1
//          jl fail2            ; If an error occured (nonpositive return value), jump to fail2.
//          jmp ebp             ; Return to the return address (the number of bytes written is already in eax).
//  fail2:  mov eax, 0          ; Set the return value to 0 to mark the error
//          jmp ebp             ; Return to the return address.
//
@_writeSomeStdout = $5D83F80275FEB804000000BB01000000595ACD8083F8017C02FFE5B800000000FFE5;

// _readSomeStdin(buf, size):
//      Read up to 'size' bytes from stdin to 'buf'. Return the number of bytes read, or (0 - 1) if
//      reading fails. 'size' must be nonzero. If 0 is returned, the end of the file has been
//      reached.
//
// Implementation in NASM syntax:
//          pop ebp             ; Pop the return address to ebp.
//          cmp eax, 2
//  fail:   jne fail            ; If the number of arguments is not 2, loop forever.
//          mov eax, 3          ; Use the "read" system call.
//          mov ebx, 0          ; Use standard input.
//          pop ecx             ; Use the 'buf' argument as buffer address.
//          pop edx             ; Use the 'size' argument as the maximum number of bytes to read.
//          int 0x80            ; Perform the system call; return value is saved to eax.
//          cmp eax, 0
//          jl fail2            ; If an error occured (negative return value), jump to fail2.
//          jmp ebp             ; Return to the return address (the number of bytes read is already in eax).
//  fail2:  mov eax, -1         ; Set the return value to (0 - 1) to mark the error.
//          jmp ebp             ; Return to the return address.
//
@_readSomeStdin = $5D83F80275FEB803000000BB00000000595ACD8083F8007C02FFE5B8FFFFFFFFFFE5;

// _runWhileTrue(func): Call func repeatedly until it returns false (0).
//
// Implementation in NASM syntax:
//          cmp eax, 1
//  fail:   jne fail            ; If the number of arguments is not 1, loop forever.
//  loop:   mov eax, 0          ; Set eax (the number of arguments for the call) to 0.
//          call [esp+4]        ; Call 'func'.
//          cmp eax, 0
//          jne loop            ; If the return value is nonzero, retry calling the function.
//          pop ebp             ; Pop the return address to ebp.
//          add esp, 4          ; Discard the 'func' argument from the stack.
//          jmp ebp             ; Return to the return address (the return value eax is already 0).
//
@_runWhileTrue = $83F80175FEB800000000FF54240483F80075F25D83C404FFE5;

//--- Control flow ---//

@runWhileTrue = [func]{
    _runWhileTrue(func)
};

@if = [cond, func]{
    @helper = { cond };
    runWhileTrue({
        @continue = helper();
        helper = {
            func();
            0
        };
        continue
    })
};

@ifElse = [cond, trueFunc, falseFunc]{
    @func = falseFunc;
    if(cond, {
        func = trueFunc
    });
    func()
};

@while = [condFunc, func]{
    runWhileTrue({
        ifElse(condFunc(), { func(); 1 }, { 0 })
    })
};

//--- Error handling (minimal implementations; replaced later) ---//

// Fail the program with given error message string. Does not return.
@fail = [msg]{
    // Go to infinite loop.
    runWhileTrue({ 1 })
};

//--- Input/output ---//

@writeStdout = [buf, size]{
    while({ size }, {
        @count = _writeSomeStdout(buf, size);
        if(count == 0, {
            fail("Writing to stdout failed")
        });
        buf = buf + count;
        size = size - count
    });
    size
};

@readStdin = [buf, size]{
    @ret = 0;
    while({ size }, {
        @count = _readSomeStdin(buf, size);
        if(count == 0 - 1, {
            fail("Reading from stdin failed")
        });
        ifElse(count, {
            buf = buf + count;
            size = size - count;
            ret = ret + count
        }, {
            // End of file encountered, stop reading.
            size = 0
        })
    });

    // Return the number of bytes read (may be short if the end of the file is encountered).
    ret
};

@printDec = [val]{
    @digit = val % 10;
    @rest = val / 10;
    if(rest, { printDec(rest) });
    digit = digit + 48;
    writeStdout(&digit, 1)
};

@printStr = [str]{
    @len = 0;
    // TODO: implement proper 8-bit read
    while({ *(str + len) % 256 }, { len = len + 1 });
    writeStdout(str, len)
};

@inputLine = {
    @ret = brk;
    runWhileTrue({
        @ch = 0;
        ifElse(readStdin(&ch, 1), {
            ifElse(ch == #A, {
                // Line break encountered.
                0
            }, {
                // Append character to string and continue.
                // TODO: implement proper 8-bit write.
                *brk = ch;
                brk = brk + 1;
                1
            })
        }, {
            // End of file encountered.
            0
        })
    });

    // Append the null terminator.
    // TODO: implement proper 8-bit write.
    *brk = 0;
    brk = brk + 1;

    ret
};

//--- Error handling (replacing earlier implementations) ---//

fail = [msg]{
    printStr("FAIL: ");
    printStr(msg);
    printStr("
");

    // Go to infinite loop.
    runWhileTrue({ 1 })
};

// Replace the wrong number of arguments handler by one that prints the information to stdout.
__builtin_wrongNumberOfArgumentsHandler = [line, column, correctArgCount, givenArgCount]{
    printStr("FAIL: Wrong number of arguments passed to the function defined on line ");
    printDec(line);
    printStr(", column ");
    printDec(column);
    printStr(" (expected ");
    printDec(correctArgCount);
    printStr(" arguments, got ");
    printDec(givenArgCount);
    printStr(").
");

    // Go to infinite loop.
    runWhileTrue({ 1 })
};

//------------------------------------------------------------------------------------------------//
// PROGRAM                                                                                        //
//------------------------------------------------------------------------------------------------//

@i = 123;
while({ i != 0 }, {
    printStr("ASD ");
    printDec(i);
    printStr("
");
    i = i - 1
});

printStr(inputLine());
printStr("
")
