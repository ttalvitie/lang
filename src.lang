% =add(...): Return the sum of all arguments.
%
% Assembly source:
%           pop ebp         ; Pop the return address to ebp.
%           pop eax         ; Pop the number of arguments to eax.
%           cmp eax, 0
%   fail:   je fail         ; If there are no arguments, loop forever. (TODO: better error handling)
%           pop ebx         ; Pop the return value address to ebx.
%           mov ecx, 0      ; Initialize result storage in ecx to zero.
%   loop:   dec eax         ; Decrement eax, maintaining it as the number of unprocessed arguments.
%           cmp eax, 0
%           je done         ; If there are no unprocessed arguments remaining, end loop.
%           pop edx         ; Pop the next argument to edx.
%           add ecx, edx    ; Add the argument to the result in ecx.
%           jmp loop        ; Continue loop.
%   done:   mov [ebx], ecx  ; Save the result to the return value address.
%           jmp ebp         ; Return to the return address.
%
add : ($5D5883F80074FE5BB9000000004883F80074055A01D1EBF5890BFFE5)

% =mul(...): Return the product of all arguments.
%
% Assembly source:
%           pop ebp         ; Pop the return address to ebp.
%           pop ecx         ; Pop the number of arguments to ecx.
%           cmp ecx, 0
%   fail:   je fail         ; If there are no arguments, loop forever. (TODO: better error handling)
%           pop ebx         ; Pop the return value address to ebx.
%           mov eax, 1      ; Initialize result storage in eax to zero.
%   loop:   dec ecx         ; Decrement ecx, maintaining it as the number of unprocessed arguments.
%           cmp ecx, 0
%           je done         ; If there are no unprocessed arguments remaining, end loop.
%           pop edx         ; Pop the next argument to edx.
%           mul edx         ; Multiple the result in eax by the argument (edx gets overwritten).
%           jmp loop        ; Continue loop.
%   done:   mov [ebx], eax  ; Save the result to the return value address.
%           jmp ebp         ; Return to the return address.
%
mul : ($5D5983F90074FE5BB8010000004983F90074055AF7E2EBF58903FFE5)

% =sub(a, b): Return the difference of 'a' and 'b'.
%
% Assembly source:
%           pop ebp         ; Pop the return address to ebp.
%           pop eax         ; Pop the number of arguments to eax.
%           cmp eax, 3
%   fail:   jne fail        ; If the number of arguments is not 3, loop forever. (TODO: better error handling)
%           pop ecx         ; Pop the return value address to ecx.
%           pop eax         ; Pop 'a' to eax.
%           pop ebx         ; Pop 'b' to ebx.
%           sub eax, ebx    ; Compute the difference to eax.
%   done:   mov [ecx], eax  ; Save the result to the return value address.
%           jmp ebp         ; Return to the return address.
%
sub : ($5D5883F80375FE59585B29D88901FFE5)

% =lt(a, b): Returns 1 if 'a' is less than 'b', and 0 otherwise.
%
% Assembly source:
%           pop ebp         ; Pop the return address to ebp.
%           pop eax         ; Pop the number of arguments to eax.
%           cmp eax, 3
%   fail:   jne fail        ; If the number of arguments is not 3, loop forever. (TODO: better error handling)
%           pop ecx         ; Pop the return value address to ecx.
%           pop eax         ; Pop 'a' to eax.
%           pop ebx         ; Pop 'b' to ebx.
%           mov edx, 0      ; Set result value to 0.
%           cmp eax, ebx
%           setb dl         ; If eax is less than ebx, set result to 1.
%           mov [ecx], edx  ; Save the result to the return value address.
%           jmp ebp         ; Return to the return address.
%
lt : ($5D5883F80375FE59585BBA0000000039D80F92C28911FFE5)

% =readStdinRaw(buf, size):
%   Read up to 'size' bytes from stdin to 'buf'. Return the number of bytes read. If 0 is returned,
%   the end of the file has been reached.
%
% Assembly source:
%           pop ebp         ; Pop the return address to ebp.
%           pop eax         ; Pop the number of arguments to eax.
%           cmp eax, 3
%   fail:   jne fail        ; If the number of arguments is not 3, loop forever. (TODO: better error handling)
%           pop edi         ; Pop the return value address to edi.
%           mov eax, 3      ; Use "read" system call.
%           mov ebx, 0      ; Use standard input.
%           pop ecx         ; Use the 'buf' argument as output address.
%           pop edx         ; Use the 'size' argument as the maximum number of bytes to read.
%           int 0x80        ; Perform the system call.
%           cmp eax, 0
%   fail2:  jl fail2        ; If an error occured (negative return value), loop forever. (TODO: better error handling)
%           mov [edi], eax  ; Save the number of read bytes to the return value address.
%           jmp ebp         ; Return to the return address.
%
readStdinRaw : ($5D5883F80375FE5FB803000000BB00000000595ACD8083F8007CFE8907FFE5)

% Define put as an alias for the empty-name 32-bit memory write function.
put : (0)
(&put, )

% Comparison operators.
eq : ([ret, a, b]{ put(ret, lt(sub(a, b), 1)) })
ne : ([ret, a, b]{ put(ret, sub(1, eq(a, b))) })
gt : ([ret, a, b]{ put(ret, lt(b, a)) })
leq : ([ret, a, b]{ put(ret, sub(1, gt(a, b))) })
geq : ([ret, a, b]{ put(ret, sub(1, lt(a, b))) })

% Logical operators.
not : ([ret, x]{ put(ret, eq(x, 0)) })
and : ([ret, a, b]{ put(ret, not(add(not(a), not(b)))) })
or : ([ret, a, b]{ put(ret, not(and(not(a), not(b)))) })

x : (0)
y : readStdinRaw(&x, 4)
put(brk, x)
